Sincerity is a lightweight, multilingual contained environment manager for the JVM.

 help [command]
 
Concepts

 Container:
 
  A set of files implementing a self-contained JVM-based execution environment 
  managed by Sincerity and by you. The container has a root path, under which it may
  have a directory structure of any depth. Libraries, binary executables, configuration
  files, temporary work files and logs are all by default stored within the container.
  
  Why such an emphasis on self-containment? One goal is for the container to be
  deployable anywhere as a whole, simply by copying the directory elsewhere. Another
  goal is for the container to be a useful playground: you can install and try out
  various applications and libraries without affecting your operating system. You can
  undo you work simply by deleting the container's directory. 
 
 Dependency:
 
  A contained, versioned, installable set of files (called 'artifacts'), which can in
  turn have its own list of dependencies. Dependencies are deployable software bundles,
  representing things like libraries, or complete applications and services.
  
  All dependencies in Sincerity are identified by a two-part name, composed of a
  'group' prefix plus a unique 'name' within the group, plus a version specifier.
  Different dependencies might have their own versioning schemes, but Sincerity is
  good at guessing these for the purposes of comparing versions.
  
  Note that a dependency can also have none of its own files, and only a list of its
  own dependencies. These are sometimes called 'meta-dependencies.'
 
 Repository:
 
  A store for dependencies and their artifacts. Repositories usually contain indexes
  of available dependencies and versions. Some repositories also have friendly
  human-facing web frontends which you can use to search for dependencies.
  
  Sincerity supports several repository technologies, and can also help you deploy
  your own dependencies to them.
 
 Artifact:
 
  A fancy way to refer to files within a dependency. Sincerity supports a specific set
  of artifact types: JVM libraries (jars), language-specific libraries (Python eggs,
  Ruby gems, PHP packages, etc.), documentation bundles, source code bundles, software
  licenses, installers, dependency descriptors and more generic 'packages' (see below).
 
 Package:
 
  This is a special kind of Sincerity-specific jar artifact that can contain other
  files, and can additionally have special install/uninstall hooks.
  
  On the one hand, it is the most straightforward artifact type, as it simply installs
  any number of files into a container. On the other hand, it is the most flexible, as
  the hooks let packages intervene in arbitrary way in the installation process. A
  common use case is for the install hook to manipulate the unpacked files in order to
  tailor them for the specific environment in which the container is running.
  
  Sincerity contains tools to help you easily create your own packages, as well as
  documentation about the package specification, so that you can manually create your
  own.
 
Command Sequences

 You can run several Sincerity commands in sequence via a single call, by chaining
 them together with a ':' argument. This is often faster and more efficient than
 running Sincerity repeatedly for each command, because a single running JVM process
 is used for all of them.

 Note that switches (arguments beginning with '--') will be applied to all relevant
 commands in the sequences. Thus, it does not matter where you place the switches
 on the command line. (There's one exception to this: the 'bootstrap' command,
 which swallows all arguments that come after it, and which must be the last command
 in any sequence.)

Specifying the Container

 Almost all commands need a container in order to work. If the current directory
 is within a container (meaning that one of its ancestors is a container root),
 then that container will be used. Otherwise, you can specify a container explicitly
 using the '--container=[path]' switch.

 Note that it is technically possible to have a container within a container. If
 you are relying on the current directory in order to select the container, then note
 that the innermost container will be used.

Container Management

 resolve
 
  Resolves the container. Resolution is a rather complicated process in which versions
  and interdependencies are straightened out, but the result is straightforward:
  all your dependencies are downloaded from the repositories and installed in your
  container, ready for action.
  
  A 'resolve' often follows one or more dependency management commands (see 'Dependency
  Management,' below).
  
  When unpacking packages, 'resolve' will not, by default, overwrite existing files.
  You can change this behavior with the '--overwrite=true' switch. (Be careful, though
  because overwritten files will be lost.)
  
 bootstrap [main class name] [[arguments for main...]]
 
  This useful command is meant to be equivalent to the JVM command line, but
  specifically for running within the container. By default, the container will be
  resolved before bootstrapping, and all libraries installed during this resolution
  process will be immediately usable.
  
  By chaining 'bootstrap' after a series of 'use' and 'add' commands, you can download,
  install and run an application with a single command line, within a single running
  JVM process.
  
  'bootstrap' works by calling the 'public static void main(String[])' method of the
  specified class, while sending it the additional command line arguments. (For this
  reason, 'bootstrap' must be the last command in a sequence of Sincerity commands.
  See 'Command Sequences,' above.) Note that in order to download a JVM library and
  immediately use it, some class-loader manipulation takes place. This may not be
  compatible with some applications and libraries that do their own class-loader
  manipulation. Those applications will have to first 'resolve' the container
  separately and then provide their own bootstrapping mechanism.
  
  'bootstrap' implicitly calls 'resolve' first, but you can turn this behavior off
  via the '--resolve=false' switch.

 create [[base path]]

  Creates a new container with the path as the root directory of the container. If
  provided, the path must be a directory. If it does not exist, it will be created.
 
  If not provided, the current directory will be used.
  
  In any case, the root directory must be empty in order for the container to be
  created there.

 reset
 
  Removes all dependencies and unuses all repositories, letting you start from
  scratch.
  
  Note that installed files are not removed by this command. You can use 'clean' or
  'prune' commands to do that after 'reset'.
  
 prune
 
  Deletes all files that previously installed by Sincerity, but which are no longer
  needed due to a change in the dependency structure. Changes can happen due to
  calling 'resolve' after one ro a series of 'remove', 'reset' or 'upgrade' commands.
  Thus, 'prune' is commonly called after 'resolve'.
  
  Note that files which were changed by you are not deleted, so you would not lose
  your work.
  
 clean
 
  Deletes all files installed by Sincerity. Calling 'resolve' would likely restore
  all of them, unless you've changed the dependency structure by, say, calling
  'reset'.
  
  The 'clean' command is useful during experimentation, but also for deployment.
  You can 'clean' the container, copy it to the target nodes, and then run 'resolve'
  on each of them in order to restore them to working order. 

  Note that files which were changed by you are not deleted, so you would not lose
  your work.

 unpack [[package name]]
 
  Unpacks one or all packages. If the package name is not provided, all packages will
  be unpacked.
 
  This command is rarely used: the 'resolve' command already handles the unpacking of
  all packages. However, it may be useful to access this facility directly, especially
  when testing packages.

  When unpacking packages, 'unpack' will not, by default, overwrite existing files.
  You can change this behavior with the --overwrite=true switch. (Be careful, though
  because overwritten files will be lost.)

Dependency Management

All dependency information is stored in the container's
'configuration/sincerity/dependencies.conf' file, which you can also manually edit.

 list
 
  Prints out the entire dependency tree since the last resolution. Sub-dependencies
  are listed indented underneath the dependency that pulled them in. This means that
  dependencies that you added explicitly are the unindented roots, and everything
  else underneath is pulled in by them.
  
  Note that dependencies may appear more than once in the list, as they are pulled
  in by different dependencies. However, even if they appear multiple times, they
  are only downloaded and installed once.  

 add [group] [name] [[version specification]]

 remove [group] [name]

Repository Management

All repository information is stored in the container's
'configuration/sincerity/repositories.conf' file, which you can also manually edit.

 use [section] [type] [name] [url]

 unuse [section] [name]
