#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{prettyref}
\newrefformat{}{section~\ref{#1}}
\sloppy
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman newcent
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 0
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The Sincerity Manual
\end_layout

\begin_layout Author
Version %VERSION%
\begin_inset Newline newline
\end_inset

Main text written by Tal Liron
\end_layout

\begin_layout Standard
\noindent
\align center
Copyright 2011-2012 by Three Crickets LLC.
\begin_inset Newline newline
\end_inset

This work is licensed under a
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License"
target "http://creativecommons.org/licenses/by-nc-sa/3.0/"

\end_inset

.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Lather, Rinse, Repeat
\end_layout

\begin_layout Standard
The free software and open source movements have utterly changed how we
 develop software.
\end_layout

\begin_layout Standard
Libraries had existed freely before, but these movements have created a
 culture of sharing, fueled by viable business models, culminating in an
 unprecedented wealth of solutions.
 For any problem you encounter in your everyday development work, there
 is likely a library out there to help you that you can download for free.
 Your mileage may vary, as they say: quality may not always be up to snuff,
 and no warranty is provided, but the source code is included and you can
 make it better, for yourself and for others.
 Importantly, it's relatively future-proof to depend on free software: you
 can be certain that your license to use the library will not be revoked
 and that bugs 
\emph on
could
\emph default
 be solved, by you, by the community, or by hired help.
\end_layout

\begin_layout Standard
(You do need to worry whether the software breaks any owned patents, but
 that problem exists for any software, whether it's free or proprietary,
 from a third party or developed by you.)
\end_layout

\begin_layout Standard
Unfortunately, this wealth also creates challenges.
 There are several packaging, versioning and delivery standards for libraries.
 And when it comes to platforms and frameworks, there is no standard way
 to deploy software on top of them.
 If your code is a composite of many of these, you will find yourself spending
 a lot of time making sense of these various schemes and integrating them
 into a system that is maintainable by you in the long run.
 And if your software is itself modular and redistributable, you will find
 yourself having to pick one of the many different methods, or inventing
 one of your own.
 So, when it comes down to it, while free software can save you a lot of
 time and effort in terms of development, you end up spending extra effort
 on integration and maintenance.
 Annoyingly, you'll find that much of this work is repetitive, unnecessarily
 so.
 If you're a programmer used to making code reusable, you'll may such repetitive
 work especially annoying.
 
\end_layout

\begin_layout Standard
When it comes to the JVM, a few products have been widely adopted that make
 some of this work easier.
 However, experience has shown them to have too small a scope: they solve
 very specific problems, but do not address the complete challenge.
 (See the 
\begin_inset Quotes eld
\end_inset

Other Solutions
\begin_inset Quotes erd
\end_inset

 section for an in-depth comparison of Sincerity to some of these existing
 solutions.) Additionally, since they are already a few years old, they predate
 the linguistic revolution that is happening in full force on the JVM: no
 longer is Java the only good choice for leveraging the platform.
 New and popular languages like Scala, Clojure and Groovy offer a new experience
 and culture, while Rhino, Jython, JRuby and Quercus bring popular languages
 and their paradigms to the JVM.
 Indeed, since version 7, the JVM has added support an opcode (invokedynamic)
 that cannot be normally generated by compiling Java language code: for
 the first time in its history, the JVM is made for languages that aren't
 Java.
\end_layout

\begin_layout Standard
With that in mind, Sincerity is designed from the ground up with multilingual
 support in mind, which means that not only is knowledge of Java code never
 required, but also that the culture of dynamic languages and their standards
 are intrinsically supported: you can include dependencies from Ruby gems,
 Python's PyPI repository and PHP's PEAR repository.
 Moreover, Sincerity has standard plugins that make installing and working
 with these dynamic languages especially easy.
\end_layout

\begin_layout Standard
You might want to jump straight to the tutorial to see how it works, but
 you're also invited to stay here and look at some of the development and
 deployment tasks that Sincerity tackles.
\end_layout

\begin_layout Subsubsection
Dependency Management and 
\begin_inset Quotes eld
\end_inset

DLL hell
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
How do you get a library working with your application? Let's see:
\end_layout

\begin_layout Enumerate
Find the library's web site
\end_layout

\begin_layout Enumerate
Look for the 
\begin_inset Quotes eld
\end_inset

download
\begin_inset Quotes erd
\end_inset

 button
\end_layout

\begin_layout Enumerate
Download the latest version: note that you want to write down all versions
 of all libraries you are using, so that you can handle upgrades and possible
 conflicts
\end_layout

\begin_layout Enumerate
Open the distribution archive: you want to be organized about this, so that
 you can find licenses, documentation, etc., later on
\end_layout

\begin_layout Enumerate
You need to make put the jar in your classpath for the following environments:
\end_layout

\begin_deeper
\begin_layout Enumerate
Your development environment: you might also want to link source code and
 documentation if they are available in the distribution
\end_layout

\begin_layout Enumerate
Your deployment environment: the application needs it to run, so you to
 need to somehow include the file in your bootstrapping script
\end_layout

\begin_layout Enumerate
Your distribution, assuming you are distributing your application: this
 is optional, since you might decide not to include this dependency, and
 to have the users download and install it themselves
\end_layout

\end_deeper
\begin_layout Enumerate
There might be configuration files (property files, XML, etc.)
\end_layout

\begin_deeper
\begin_layout Enumerate
You might need to make different versions of these for your different environmen
ts
\end_layout

\begin_layout Enumerate
The configuration files might not be flexible enough for how your application
 runs, with too much assumed or hardcoded, so you will need to either:
\end_layout

\begin_deeper
\begin_layout Enumerate
Document this fact for the user to handle on their own
\end_layout

\begin_layout Enumerate
Generate the configuration files during your application's bootstrapping
 process
\end_layout

\begin_layout Enumerate
Patch the library to allow for the flexibility you require
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Once in a while you want to check for upgrades, which might mean subscribing
 to an RSS feed or mailing list, or just reminding yourself to check the
 web site
\end_layout

\begin_layout Enumerate
The library might have requirements, so you need to make sure to do all
 the above for them
\end_layout

\begin_layout Standard
The above is a lot of work.
 And what if you have 20 dependencies?
\end_layout

\begin_layout Standard
This is not a new problem, and there are already a few solutions for it.
 For one, there is a straightforward standard for JVM repositories, iBiblio,
 which is widely used by many projects.
 But it requires you to use one of two tools: Ivy, which does a good job
 of downloading dependencies (and is used internally by Sincerity), but
 does nothing else, or Maven, which is a sophisticated, heavyweight project
 management tool with a steep learning curve, and which requires you to
 work entirely within its domain.
 We'll compare these tools in more depth to Sincerity later on, but for
 now let's just say that the former is too limited in scope, and the latter
 too constraining.
 There are also various difficulties in configuring these tools: Sincerity
 
\begin_inset Quotes eld
\end_inset

just works,
\begin_inset Quotes erd
\end_inset

 immediately and easily.
\end_layout

\begin_layout Standard
There's also the problem of working in a bubble: if you are using Jython,
 JRuby or Quercus, then you have to also work with the repository standards
 of Python (PyPI), Ruby (gems) and PHP (PEAR).
 Sincerity is designed to support all of these standards.
\end_layout

\begin_layout Standard
Then there's the issue of potential conflicts, a.
 k.
 a.
 
\begin_inset Quotes eld
\end_inset

DLL hell
\begin_inset Quotes erd
\end_inset

: What if one application you're working on requires one version of a specific
 library, and another application requires another? What if this happens
 within different parts of the same application? Again, there are standards
 and tools for this---OSGi and Jigsaw---but they require to work entirely
 within the paradigms they enforce.
 Sincerity doesn't stop you from using them (in fact, it has great support
 for the Felix OSGi container), but definitely does not force you to play
 by any special rules.
 From the bottom up, Sincerity is designed to be as straightforward and
 universal as possible.
 See the detailed comparison to OSGi, below, for more information.
\end_layout

\begin_layout Subsubsection
Bootstrapping
\end_layout

\begin_layout Standard
The JVM is packaged as a set of command line utilities, plus a few plugins
 for specialized environments.
 It does come with one simple way to distribute programs---executable JAR
 files---but that would only suffice for the most trivial programs.
\end_layout

\begin_layout Standard
For anything more complex, you will need to handle bootstrapping your applicatio
n.
 This means, at the very least, finding the right JVM on the machine (more
 than one may be installed), and then loading the application via the 
\begin_inset Quotes eld
\end_inset

java
\begin_inset Quotes erd
\end_inset

 tool.
 Usually, however, it ends up being far more complicated: rummaging through
 environment variables, detecting the host operating system and environment
 in order to set specialized JVM flags and load optimized native libraries,
 and because this is so complex, you'll want to responding to specialized
 bootstrapping flags set by the user.
 Indeed, many JVM-based products won't 
\begin_inset Quotes eld
\end_inset

just run,
\begin_inset Quotes erd
\end_inset

 but will in fact require you to set a host of environment variables first.
\end_layout

\begin_layout Standard
All this work happens before the JVM even starts.
 Thus, it's usually handled by writing a shell script, which is almost always
 immediately runnable.
 Depending on how many operating systems you want to support, this may mean,
 at the very least, writing one for *nix systems and one for Windows systems.
 This is highly specialized work, and a development project with its own
 challenges, so some projects choose to avoid scripts, and develop native
 binaries that handle bootstrapping.
 And then there are installer products that purport to do this all for you.
\end_layout

\begin_layout Standard
And what if you want the software to run as a daemon, system service, or
 cron job?
\end_layout

\begin_layout Standard
And what if your software is not just one program, but also contains a set
 of tools that you also need to bootstrap?
\end_layout

\begin_layout Standard
The bottom line is that bootstrapping is very hard to get right, and there
 are many complicated approached to it.
 It's a shame that so many JVM products keep trying to implement the same
 bootstrapping solutions from scratch.
 Sincerity streamlines this in two ways: first, by providing you with working
 shell scripts, and second, by having these scripts delegate the process
 as soon as possible to a JavaScript program running in the JVM.
 Once on the JVM, Sincerity offers a range of installable plugins that handle
 various configuration and deployment tasks, including running the software
 as a daemon.
\end_layout

\begin_layout Standard
(Why JavaScript and not a different scripting language? We deal with the
 question in length below.)
\end_layout

\begin_layout Standard
What this means is that most products won't have to do anything beyond what
 Sincerity offers out of the box, and those with specialized bootstrapping
 will be able to write portable JavaScript programs, instead of having to
 deal with complex shell scripting.
\end_layout

\begin_layout Subsubsection
Configuration and 
\begin_inset Quotes eld
\end_inset

XML hell
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Between bootstrapping and reaching full usability, your product has to configure
 itself.
 Will you choose a properties file? XML? Something else? And where is the
 file located?
\end_layout

\begin_layout Standard
Well, consider that all the libraries you use had to make their own choices
 for configuration.
 A non-trivial JVM product could thus require several configuration files,
 in different locations, with different configuration rules.
\end_layout

\begin_layout Standard
But there's a more serious problem to most of these approaches: they are
 unnecessarily rigid and static.
 While there are many advantages to using text files for configuration,
 the choice of technologies is baffling.
 Possibly the worst choice is XML.
 This language, ostensibly a 
\begin_inset Quotes eld
\end_inset

markup
\begin_inset Quotes erd
\end_inset

 language, is marking up nothing when used for configuration: it's instead
 used as a cumbersome format for structured textual data.
 And it gets far, far worse: XML configuration files are often used 
\emph on
programatically
\emph default
 in the JVM world, to construct JVM classes and call JVM methods.
 The best known, worst offenders are log4j and Jetty.
 There, XML is used as if it were a scripting language, the clumsiest you
 have ever seen.
\end_layout

\begin_layout Standard
The use of XML for configuration is part of what we call 
\begin_inset Quotes eld
\end_inset

XML hell,
\begin_inset Quotes erd
\end_inset

 which refers to programmers being swamped with countless overly-verbose
 XML files.
 XML is also often abused as an interchange format on the Internet, and
 a descriptor format in much of the JVM enterprise industry.
 Enough already!
\end_layout

\begin_layout Standard
The excuse for this insanity, one would guess, is that the ability to parse
 XML is standard on many platforms, including the JVM.
 But, 
\emph on
interpreting 
\emph default
this XML is far more complicated that just parsing it.
 In essence, parsing a general-purpose XML for something like Jetty involves
 writing a complete (more likely, not complete enough) scripting language
 engine.
 Another excuse for 
\begin_inset Quotes eld
\end_inset

XML hell
\begin_inset Quotes erd
\end_inset

 could be part of the general over-enthusiasm with XML, and the untested
 faith that standardizing on a single format would lead to greater interoperabil
ity.
 Again, this is madness: unless you couple the XML file with the code that
 can make sense of it, the ability to parse them is of little use.
\end_layout

\begin_layout Standard
Another approach, better than XML, is to create a Domain-Specific Language
 (DSL).
 But DSLs require a lot of work, both by developers and by users who must
 learn them.
\end_layout

\begin_layout Standard
Sincerity is here to stop the madness: wherever possible, it standardizes
 on using JavaScript for configuration.
 (Why JavaScript? We deal with the question in length below.) With JavaScript
 you can instantiate objects, call methods, insert conditionals and loops
 using natural programming paradigms, instead of shoe-horning them into
 XML.
 At its simplest, a JavaScript configuration file can look identical to
 a simple properties file: straightforward assignments of values to configuratio
n parameters.
 But, you also have the option of injecting interpreted code where appropriate.
 And, of course, it's still just text files that don't need to be compiled,
 and can even be picked up and re-interpreted at runtime, so you're still
 absolutely within the 
\begin_inset Quotes eld
\end_inset

configuration-by-text-file
\begin_inset Quotes erd
\end_inset

 paradigm.
\end_layout

\begin_layout Standard
If you've never tried the 
\begin_inset Quotes eld
\end_inset

configuration-by-script
\begin_inset Quotes erd
\end_inset

 approach before, you might be skeptical about its benefits or worried about
 the extra weight it adds.
 But Sincerity's JavaScript engine is very lightweight, and we're convinced
 that once you try this approach, you will never want another.
 For an instructive example, install Sincerity's logging plugin, and take
 a look at the logging configuration files.
 Now compare them to the 
\begin_inset Quotes eld
\end_inset

official
\begin_inset Quotes erd
\end_inset

 log4j formats.
\end_layout

\begin_layout Standard
One consequence of this approach is that the line between bootstrapping
 and configuration gets blurred.
 They end up as one integrated phase: a bunch of JavaScript programs strapped
 together.
 This leads to both simplification and greater flexibility for you.
 This approach leads to exceptionally dynamic configuration systems that
 can adopt to any operating environment.
\end_layout

\begin_layout Standard
We really hope to see 
\begin_inset Quotes eld
\end_inset

configuration-by-script
\begin_inset Quotes erd
\end_inset

 used throughout the JVM world, even for projects that do not want to or
 cannot use Sincerity.
\end_layout

\begin_layout Subsubsection
Logging
\end_layout

\begin_layout Standard
The JVM has a few good, widely-used logging APIs, as well as a great glue
 library---SLF4J---that can bridge between them.
 But there's quite a bit of work involved in getting all these libraries
 working together.
 It seems that every JVM product has its own way of doing this.
 Logging is important, and can't be relegated to an afterthought: if it's
 not properly configured and well integrated, it's close to useless.
\end_layout

\begin_layout Standard
Sincerity takes logging very seriously: it provides a plugin that does much
 of the work for you, and extensions that further enhance logging.
 For example, one extension funnels all logs to a centralized MongoDB collection
, perfect for distributed cloud deployments.
 And this system will work with practically 
\emph on
any 
\emph default
JVM library.
\end_layout

\begin_layout Standard
Note that logging configuration is handled via the 
\begin_inset Quotes eld
\end_inset

configuration-by-script
\begin_inset Quotes erd
\end_inset

 approach mentioned above, and is well integrated with the whole ecology
 of Sincerity plugins.
\end_layout

\begin_layout Subsection
Why JavaScript?
\end_layout

\begin_layout Standard
There are many great scripting languages for the JVM.
 Note that by 
\begin_inset Quotes eld
\end_inset

scripting
\begin_inset Quotes erd
\end_inset

 here we mean languages that are immediately runnable from the textual source
 code.
 This doesn't have to mean that are strictly interpreted: many of these
 languages compile some or all of such code on-the-fly.
 So, why hasn't Sincerity standardized on Groovy, Scala, Clojure, Lua, Python,
 Ruby or others?
\end_layout

\begin_layout Standard
There's no single answer, but rather a combination of factors that make
 JavaScript attractive:
\end_layout

\begin_layout Enumerate
JavaScript is very well known.
 Since it has been introduced into web browsers, it has gained an enormous
 skill share in the industry.
 There's a wealth of education material for it available.
\end_layout

\begin_layout Enumerate
Its implementations are relatively lightweight, in that JavaScript is both
 fairly minimal linguistically, and also does not have anything like a standard
 library, of the kind you would find in Python and Ruby.
 Thus the Rhino JavaScript engine, which Sincerity currently uses, allows
 Sincerity to have a much smaller footprint than if it were to use Jython,
 JRuby or even Groovy.
 Note that not having a standard library can also be seen as a disadvantage,
 but in the case of Sincerity it's dealt with in two ways:
\end_layout

\begin_deeper
\begin_layout Enumerate
Since we are running JavaScript on the JVM, we have full access to the Java
 standard library.
\end_layout

\begin_layout Enumerate
Sincerity comes with the 
\begin_inset Quotes eld
\end_inset

Sincerity Framework,
\begin_inset Quotes erd
\end_inset

 a very lightweight library, written in JavaScript, that makes working with
 JavaScript on the JVM a little bit easier.
\end_layout

\end_deeper
\begin_layout Enumerate
JavaScript is very future-proof: not only is it an open standard (where
 it's called 
\begin_inset Quotes eld
\end_inset

ECMAScript
\begin_inset Quotes erd
\end_inset

), but it will be baked into Oracle's JVM distribution from version 8, as
 the Nashorn engine.
 (Get it? 
\begin_inset Quotes eld
\end_inset

Nashorn
\begin_inset Quotes erd
\end_inset

 is German for 
\begin_inset Quotes eld
\end_inset

rhinoceros.
\begin_inset Quotes erd
\end_inset

) Nashorn will also make good use of the dynamicinvoke opcode introduced
 in version 7, promising especially good performance.
 Sincerity may very well migrate to Nashorn when it becomes available, or
 at least offer it as an option.
\end_layout

\begin_layout Enumerate
It's actually a nice language! JavaScript has been the target of a lot of
 negativity from programmers who had to work with it in browser environments.
 But, we believe the fault is more of the environment (the browser DOM's
 poor API and many annoying differences between various browser implementations
 of it) than the language itself.
 In fact, JavaScript shares much of its scoping and function handling with
 Scheme, a language that is generally admired.
 Think of it this way: JavaScript is Scheme with a C-like syntax.
\end_layout

\begin_layout Standard
Despite these 
\emph on
general
\emph default
 advantages, you might still prefer to use another scripting language for
 your own work.
 Luckily, Sincerity, with the help of the Scripturian library, will let
 you write plugins in Python, Ruby, Clojure, Groovy or PHP.
 The only disadvantage is that you would have to include the appropriate
 language engine as a dependency.
 In the interest of keeping Sincerity and its ecology of plugins lean and
 mean, we want to encourage the use of JavaScript for plugins that are intended
 to be shared with the community.
\end_layout

\begin_layout Standard
Just to be 100% clear: this preference for JavaScript only applies to Sincerity
 plugins, configuration scripts, and skeletons: you are definitely welcome
 to write your application in whatever language you choose.
 In fact, Sincerity contains great plugins for many popular JVM languages,
 as well as skeletons for complete language-specific frameworks, such as
 Django and Rails.
\end_layout

\begin_layout Subsubsection
JavaScript vs.
 Shell Scripting
\end_layout

\begin_layout Standard
This section is meant for those of you who are comfortable with shell scripting,
 and are not very excited about Sincerity's use of JavaScript for bootstrapping.
\end_layout

\begin_layout Enumerate
You might think that shell scripting would always be more portable than
 a scripting language running inside the JVM.
 But, think again: the point of your bootstrapping work is to get 
\emph on
into
\emph default
 the JVM, in order to run your application.
 If that doesn't work, then your whole application won't run, and portability
 is moot.
 Sincerity 
\emph on
does
\emph default
 have shell scripts, but they're designed is to delegate to the JVM as soon
 as they can.
\end_layout

\begin_layout Enumerate
Starting up the JVM with all the JavaScript engine classes is much slower
 than starting up a shell script.
 This is true, no doubt, but since version 7 the JVM is doing better.
 Also consider that you have to get into the JVM anyway.
 Still, if your application has a lot of tools that do not always require
 the JVM, and would be adversely affected by the JavaScript bootstrap times,
 then by all means write them as shell scripts! You can use all of Sincerity's
 other features when you need them.
\end_layout

\begin_layout Enumerate
Shell scripts treat most of your program as an opaque, black box.
 But with JavaScript running in the JVM you can call parts of your API before
 the application truly starts.
 This can allow for much more powerful, dynamic bootstrapping.
\end_layout

\begin_layout Enumerate
JavaScript is likely richer than your shell language.
 Sure, bash 4.0 and PowerShell are a leap forward compared to what we had
 20 years ago, but c'mon.
\end_layout

\begin_layout Subsection
Comparisons with Other Solutions
\end_layout

\begin_layout Subsubsection
Sincerity vs.
 Maven
\end_layout

\begin_layout Standard
Maven is a comprehensive solution for managing Java projects, handling building,
 dependency management and distribution.
 It contrastingly combines a lot flexibility on the one hand---an open plugin
 API built on the Plexus IoC container---with deliberate rigidity on the
 other hand: a strict reactor-based, multi-phase cycle.
 In particular, Maven's design goes to great lengths to keep you from affecting
 the order of operations: you are supposed to configure your project, and
 let Maven decide what to do when.
 For those used to scripting their build process, this approach may initially
 seem baffling and restricting.
 However, there are significant benefits to this approach when working with
 very large, complex projects: instead of coding and maintaining nightmarishly
 long build scripts based on dozens of changing environment variables, you
 can sit back and let Maven analyze the entire operation and then do the
 right thing.
\end_layout

\begin_layout Standard
But, for this to work, you need to play by Maven's rules, and that's where
 things get tricky.
 Small deviations from the strict assumptions Maven makes throw you down
 the rabbit hole of plugins and hacks, as you struggle to shoe-horn a simple
 procedure into a product that abhors procedure.
 Specifically, Maven's ideal environment is one in which your versioned
 modules are written in Java mapped to single jar files.
\end_layout

\begin_layout Standard
Both Sincerity and Maven handle downloading dependencies, but other than
 this apparent overlap these products have different goals and scope.
 Importantly, they can be very complementary.
 One way to think of this is that Maven could come first and Sincerity come
 second: Maven could help you build your project and repositories, while
 Sincerity would handle your deployment container.
 Maven wont't help you run your application: its output is jars of compiled
 code, source code or documentation, but it doesn't handle their bootstrapping
 or runtime configuration.
 On the other hand, Sincerity does not build your project, nor make any
 assumptions about how its built: you can use Maven, Ant or anything else.
\end_layout

\begin_layout Subsubsection
Sincerity vs.
 OSGi
\end_layout

\begin_layout Standard
An 
\begin_inset Quotes eld
\end_inset

interface
\begin_inset Quotes erd
\end_inset

 in the JVM lets you create a standard protocol, such that you plug in various
 implementations of it---
\begin_inset Quotes eld
\end_inset

classes,
\begin_inset Quotes erd
\end_inset

 with 
\begin_inset Quotes eld
\end_inset

methods
\begin_inset Quotes erd
\end_inset

 as the entry points---at runtime.
 The protocol is enforced by the JVM, which will not let you plug in implementat
ions that do not fit the interface.
 OSGi takes this up a level, by providing a much broader concept of 
\begin_inset Quotes eld
\end_inset

implementation.
\begin_inset Quotes erd
\end_inset

 The implementation is a 
\begin_inset Quotes eld
\end_inset

bundle
\begin_inset Quotes erd
\end_inset

 that can contain any number of classes.
\end_layout

\begin_layout Standard
So far so good, but it gets complicated fast.
 OSGi takes it up one level more: the protocols are published and endorsed
 by a community of providers, with the idea that different providers (software
 vendors or departments in a large enterprise) can provide bundles to implement
 them, which would all work together perfectly.
 With this broader ambition, 
\begin_inset Quotes eld
\end_inset

DLL hell
\begin_inset Quotes erd
\end_inset

 suddenly becomes a far more malevolent enemy: bundles are often black boxes
 that you cannot easily patch to use a shared version of a dependency.
 There's thus a real needs for a built-in solution, which OSGi provides
 via a system of classloaders.
\end_layout

\begin_layout Standard
\SpecialChar \ldots{}
Which, of course, introduces its own set of problems.
 To get its classloading scheme to work, OSGi requires strict separation
 of classloading between bundles, which in turn adds subtle and mischievous
 restrictions to your usual JVM work.
 This is not entirely bad: working within these limitations does encourage
 clean, sharp boundaries between your modules, and goes a long way towards
 reducing classloading confusion.
 It's not, however, trivial by any means, and all your bundles must be designed
 with this in mind for OSGi to work properly.
\end_layout

\begin_layout Standard
One very useful side effect of having the framework control classloading
 is that entire bundles can be loaded and unloaded during runtime.
 Indeed, OSGi defines protocols far starting, stopping and hotswapping services.
 This is a powerful feature in itself, and is indeed the entire motivation
 for using OSGi in some cases.
 (Though, if that's your reason, you might want to look at other, simpler
 ways to enable hotswapping, rather than embracing the whole of OSGi.)
\end_layout

\begin_layout Standard
It's worth noting, however, that there is a more straightforward solution
 to the problem of 
\begin_inset Quotes eld
\end_inset

DLL hell
\begin_inset Quotes erd
\end_inset

: Why not run each 
\begin_inset Quotes eld
\end_inset

bundle
\begin_inset Quotes erd
\end_inset

 as a separate process? Each JVM would load its own classes as necessary,
 and never will they mix or conflict.
 This makes a lot of sense if you're running a distributed system, since
 you're already dividing your software among many machines and processes,
 and indeed many parts of your application may not be JVM-based at all,
 and can't be run in a single process anyway.
 As for starting and stopping your 
\begin_inset Quotes eld
\end_inset

bundles,
\begin_inset Quotes erd
\end_inset

 the operating system already does a good job of managing processes, so
 you don't need OSGi's protocol for that.
 From this perspective, you can see that OSGi is, in effect, creating a
 virtual operating system 
\emph on
inside
\emph default
 the JVM, where 
\begin_inset Quotes eld
\end_inset

bundles
\begin_inset Quotes erd
\end_inset

 are very much like operating system processes.
\end_layout

\begin_layout Standard
Indeed, the original target environment for OSGi was precisely one in which
 all bundles run in a single process, in shared memory space: it is the
 world of embedded computing, where the runtime is variously confined, such
 that you are either limited to a single process for security concerns,
 or due to limited resources.
 In such environments OSGi may be your only good solution for the problem
 of modularity and pluggable services.
 Still, OSGi has also proved popular in large enterprise environments, where
 it allows for modules to be treated more abstractly whether or not they
 are running in a single process.
\end_layout

\begin_layout Standard
Sincerity, in itself, takes the more straightforward approach: such high-level
 modularity is provided through the notion of 
\begin_inset Quotes eld
\end_inset

containers,
\begin_inset Quotes erd
\end_inset

 which you can easily create, clone and change, and start and stop as processes
 (the service plugin makes it especially easy to run them daemons and services).
 Containers can then talk to each other (and to other services) using whatever
 technology is appropriate, be it REST, SOAP, message queuing, Hazelcast,
 etc.
 That said, OSGi may indeed be appropriate for your project, and Sincerity
 provides a nice Felix plugin to get you up and running.
 The point being that Sincerity was designed to be 
\emph on
neutral 
\emph default
to the technology
\emph on
 
\emph default
of modularity, introducing no special restrictions for users that do not
 need them.
\end_layout

\begin_layout Section
Tutorial
\end_layout

\begin_layout Subsection
Install Sincerity
\end_layout

\begin_layout Standard
You need a JVM, at least version 5.
\end_layout

\begin_layout Standard
If you're an Ubuntu user, then use our repository! It would do everything
 for you.
\end_layout

\begin_layout Standard
Otherwise, download the Sincerity distribution, unpack the folder, and put
 it in any standard location.
 Suggestions:
\end_layout

\begin_layout Itemize
Windows: C:
\backslash
Program Files
\backslash
Sincerity
\end_layout

\begin_layout Itemize
Unix: /opt/sincerity
\end_layout

\begin_layout Itemize
Mac OS X: Applications
\end_layout

\begin_layout Standard
You can then run the 
\begin_inset Quotes eld
\end_inset

sincerity
\begin_inset Quotes erd
\end_inset

 script (Unix and mac) or 
\begin_inset Quotes eld
\end_inset

sincerity.bat
\begin_inset Quotes erd
\end_inset

 (Windows).
\end_layout

\begin_layout Standard
You might want to add the Sincerity path to your system path, to allow for
 easy access from the command line.
\end_layout

\begin_layout Subsection
Working with the Command Line
\end_layout

\begin_layout Standard
We'll start by pointing out that Sincerity can run in Graphical User Interface
 (GUI) mode with the 
\begin_inset Quotes eld
\end_inset

--gui
\begin_inset Quotes erd
\end_inset

 command line switch.
 But, it's strongly recommended that you learn how to use the command line.
\end_layout

\begin_layout Standard
Install Python, install a library, and run a script
\end_layout

\begin_layout Standard
Create a web server, just like that.
\end_layout

\begin_layout Subsection
Working with the Graphical User Interface (GUI)
\end_layout

\begin_layout Subsection
Programs
\end_layout

\begin_layout Standard
Execute JavaScript code in the container
\end_layout

\begin_layout Standard
Compile and execute Java code in the container
\end_layout

\begin_layout Standard
Ruby, Groovy, etc.
\end_layout

\begin_layout Subsection
Plugins
\end_layout

\begin_layout Subsection
Skeletons
\end_layout

\begin_layout Subsection
Basic Concepts
\end_layout

\begin_layout Subsubsection
Container
\end_layout

\begin_layout Standard
A set of files implementing a self-contained JVM-based execution environment
 managed by Sincerity and by you.
 The container has a root path, under which it may have a directory structure
 of any depth.
 Libraries, binary executables, configuration files, temporary work files
 and logs are all by default stored within the container.
\end_layout

\begin_layout Standard
Why such an emphasis on self-containment? One goal is for the container
 to be deployable anywhere as a whole, simply by copying the directory elsewhere.
 Another goal is for the container to be a useful playground: you can install
 and try out various applications and libraries without affecting your operating
 system.
 You can undo you work simply by deleting the container's directory.
\end_layout

\begin_layout Subsubsection
Dependency
\end_layout

\begin_layout Standard
A contained, versioned, installable set of files (called 
\begin_inset Quotes eld
\end_inset

artifacts
\begin_inset Quotes erd
\end_inset

), which can in turn have its own list of dependencies.
 Dependencies are deployable software bundles, representing things like
 libraries, or complete applications and services.
\end_layout

\begin_layout Standard
All dependencies in Sincerity are identified by a two-part name, composed
 of a 
\begin_inset Quotes eld
\end_inset

group
\begin_inset Quotes erd
\end_inset

 prefix plus a unique 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 within the group, plus a version specifier.
 Different dependencies might have their own versioning schemes, but Sincerity
 is good at guessing these for the purposes of comparing versions.
\end_layout

\begin_layout Standard
Note that a dependency can also have none of its own files, and only a list
 of its own dependencies.
 These are sometimes called 
\begin_inset Quotes eld
\end_inset

meta-dependencies.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Artifact
\end_layout

\begin_layout Standard
A fancy way to refer to files within a dependency.
 Sincerity supports a specific set of artifact types: JVM libraries (jars),
 language-specific libraries (Python eggs, Ruby gems, PHP packages, etc.),
 documentation bundles, source code bundles, software licenses, installers,
 dependency descriptors and more generic 
\begin_inset Quotes eld
\end_inset

packages
\begin_inset Quotes erd
\end_inset

 (see below).
 
\end_layout

\begin_layout Subsubsection
Package
\end_layout

\begin_layout Standard
This is a special kind of Sincerity-specific jar artifact that can contain
 other files, and can additionally have special install/uninstall hooks.
\end_layout

\begin_layout Standard
On the one hand, it is the most straightforward artifact type, as it simply
 installs any number of files into a container.
 On the other hand, it is the most flexible, as the hooks let packages intervene
 in arbitrary way in the installation process.
 A common use case is for the install hook to manipulate the unpacked files
 in order to tailor them for the specific environment in which the container
 is running.
\end_layout

\begin_layout Standard
Sincerity contains tools to help you easily create your own packages, as
 well as documentation about the package specification, so that you can
 manually create your own.
 
\end_layout

\begin_layout Subsubsection
Repository
\end_layout

\begin_layout Standard
A store for dependencies and their artifacts.
 Repositories usually contain indexes of available dependencies and versions.
 Some repositories also have friendly human-facing web frontends which you
 can use to search for dependencies.
\end_layout

\begin_layout Standard
Sincerity supports several repository technologies, and can also help you
 deploy your own dependencies to them.
 
\end_layout

\begin_layout Subsubsection
Shortcut
\end_layout

\begin_layout Subsubsection
Plugin
\end_layout

\begin_layout Subsubsection
Skeleton
\end_layout

\begin_layout Subsubsection
Template
\end_layout

\begin_layout Subsection
What Is a Container?
\end_layout

\begin_layout Standard
A strict structure, non-negotiable, non-configurable.
 Use symbolic links to get away from it.
\end_layout

\begin_layout Subsubsection
/programs/
\end_layout

\begin_layout Subsubsection
/logs/
\end_layout

\begin_layout Subsubsection
/cache/
\end_layout

\begin_layout Subsubsection
/configuration/
\end_layout

\begin_layout Subsubsection
/configuration/sincerity/
\end_layout

\begin_layout Subsubsection
/libraries/
\end_layout

\begin_layout Subsubsection
/libraries/jars/
\end_layout

\begin_layout Subsubsection
/libraries/scripturian/
\end_layout

\begin_layout Subsubsection
/libraries/scripturian/plugins/
\end_layout

\begin_layout Subsubsection
/libraries/scripturian/installers/
\end_layout

\begin_layout Subsubsection
/libraries/python/
\end_layout

\begin_layout Subsubsection
/libraries/web/
\end_layout

\begin_layout Subsubsection
/reference/
\end_layout

\begin_layout Subsubsection
/reference/documentation/
\end_layout

\begin_layout Subsubsection
/reference/licenses/
\end_layout

\begin_layout Subsubsection
/reference/sources/
\end_layout

\begin_layout Section
Language Plugins
\end_layout

\begin_layout Subsection
JavaScript Plugin
\end_layout

\begin_layout Standard
JavaScript is the Sincerity's 
\begin_inset Quotes eld
\end_inset

native
\begin_inset Quotes erd
\end_inset

 language, so this plugin is especially lightweight:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add javascript : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All it does is provide you with a command with easy access to a JavaScript
 shell:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity javascript
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The JavaScript shell provides a great way to test out code for developing
 plugins.
\end_layout

\begin_layout Subsection
Python Plugin
\end_layout

\begin_layout Subsection
Ruby Plugin
\end_layout

\begin_layout Standard
Ruby uses the following shebang:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env jruby
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But if you use Sincerity's 
\begin_inset Quotes eld
\end_inset

delegate:execute
\begin_inset Quotes erd
\end_inset

 command, it will work fine, because 
\begin_inset Quotes eld
\end_inset

/executables/jruby
\begin_inset Quotes erd
\end_inset

 is included in the environment's path, and that script in turn properly
 bootstraps the container's Ruby.
\end_layout

\begin_layout Subsection
PHP Plugin
\end_layout

\begin_layout Subsection
Groovy Plugin
\end_layout

\begin_layout Subsection
Clojure Plugin
\end_layout

\begin_layout Standard
Clojure is a modern Lisp designed from the ground up to provide excellent
 concurrency and high performance.
\end_layout

\begin_layout Subsection
Scala Plugin
\end_layout

\begin_layout Section
Feature Plugins
\end_layout

\begin_layout Subsection
Logging Plugin
\end_layout

\begin_layout Standard
/configuration/logging.conf
\end_layout

\begin_layout Subsection
Service Plugin
\end_layout

\begin_layout Subsection
Felix OSGi Plugin
\end_layout

\begin_layout Standard
As an example, let's install the web console.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

install http://archive.apache.org/dist/felix/org.apache.felix.http.jetty-2.2.0.jar
\end_layout

\begin_layout Plain Layout

install http://archive.apache.org/dist/felix/org.apache.felix.webconsole-3.1.8.jar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You'll then need to start both bundles.
\end_layout

\begin_layout Standard
Point your browser to http://localhost:8080/system/console/.
 The default user is 
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

 with password 
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Markup Plugin
\end_layout

\begin_layout Subsubsection
Batik SVG Plugin
\end_layout

\begin_layout Section
Skeletons
\end_layout

\begin_layout Standard
You've most likely come to Sincerity for the skeletons: they provide the
 easiest way to get started with all kinds of frameworks, servers and libraries,
 while Sincerity lets you easily add more features, more libraries and more
 languages as your project grows.
\end_layout

\begin_layout Subsection
Nexus Repository Skeleton
\end_layout

\begin_layout Standard
Sonatype's Nexus repository manager is a highly recommended companion for
 Sincerity.
 At its most basic, it provides you with a proxy for accessing remote repositori
es, such as the Three Crickets repository in which many Sincerity packages
 are stored.
 Accessing repositories via a proxy provides you with much better performance
 and reliability.
\end_layout

\begin_layout Standard
Sincerity makes it very easy to install to Nexus:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add nexus : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To start the server:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity start jetty
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default port is 8080, so point your browser to http://localhost:8080
 to see your new Nexus repository.
\end_layout

\begin_layout Subsubsection
Extras
\end_layout

\begin_layout Standard
Adding the service plugin is strongly recommended.
 To install:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add service : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that Nexus uses its own logging implementation, which is unfortunately
 incompatible with Sincerity's logging plugin.
\end_layout

\begin_layout Standard
The following command will install a Nexus repository with the recommended
 plugins into a Sincerity container created in the current directory, and
 then start it a service:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity create mycontainer : add nexus : add service : install : service
 jetty start
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To stop it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity use mycontainer : service jetty stop
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Jetty Web Server Skeleton
\end_layout

\begin_layout Standard
Need a web server for static files? No problem:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add jetty.web : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Jetty is a very robust, modular web server with excellent asynchronous performan
ce, and lots of features and extensions.
 With this skeleton we've provided you with the lightweight, bare minimum
 dependencies to serve just static files for a single web site.
\end_layout

\begin_layout Standard
To start you server:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity start jetty
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default port is 8080, so point your browser to http://localhost:8080
 to see the default welcoming page.
\end_layout

\begin_layout Standard
Jetty allows for much more sophistication than just serving a single web
 site, and for that we've provided a separate skeleton: 
\begin_inset Quotes eld
\end_inset

jetty.servlet
\begin_inset Quotes erd
\end_inset

.
 That skeleton supports multiple 
\begin_inset Quotes eld
\end_inset

contexts
\begin_inset Quotes erd
\end_inset

 under the server, as well as configuration of connectors, and of course
 servlets and web applications packaged as WAR files.
\end_layout

\begin_layout Standard
Additionally, Jetty is a recommended connector for Restlet.
 It's available as 
\begin_inset Quotes eld
\end_inset

restlet.jetty
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Fleshing Out
\end_layout

\begin_layout Standard
Just put your files under the container's 
\begin_inset Quotes eld
\end_inset

/web/
\begin_inset Quotes erd
\end_inset

 directory, using the usual rules for web servers: URLs are mapped to file
 paths under 
\begin_inset Quotes eld
\end_inset

/web/
\begin_inset Quotes erd
\end_inset

, and directory URLs are mapped to 
\begin_inset Quotes eld
\end_inset

index.html
\begin_inset Quotes erd
\end_inset

 files in that directory.
 MIME types are automatically guessed according to the common filename extension
s.
\end_layout

\begin_layout Standard
You can configure the server by editing 
\begin_inset Quotes eld
\end_inset

/programs/jetty.js
\begin_inset Quotes erd
\end_inset

.
 For example, you can change the port, add an SSL connector (for https URLs)
 and configure new MIME types.
\end_layout

\begin_layout Subsubsection
Extras
\end_layout

\begin_layout Standard
Two plugins are strongly recommended: logging and service.
 To install them:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add logging : add service : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following command will install a web server with the recommended plugins
 into a Sincerity container created in the current directory, and then start
 it a service:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity create mycontainer : add jetty.web : add logging : add service
 : install : service jetty start
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To stop it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity use mycontainer : service jetty stop
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Jetty Servlet Skeleton
\end_layout

\begin_layout Standard
Servlets let you generate dynamic content for a web site, usually using
 the Java language.
 There is a very large ecosystem of free servlets out there, including complete
 frameworks, that can help you develop dynamic applications.
\end_layout

\begin_layout Standard
To install a barebones servlet skeleton, based on Jetty:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add jetty.servlet : install
\end_layout

\end_inset

To start you server:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity start jetty
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default port is 8080, so point your browser to http://localhost:8080.
 But, you won't see anything yet: this is a barebones skeleton waiting for
 you to add your application.
 You might want to start with 
\begin_inset Quotes eld
\end_inset

jetty.servlet.example
\begin_inset Quotes erd
\end_inset

 first.
\end_layout

\begin_layout Standard
As useful as servlets are, we recommend you take a look at the 
\begin_inset Quotes eld
\end_inset

restlet
\begin_inset Quotes erd
\end_inset

 skeleton if you want to build a dynamic web application in Java.
 And Restlet can use Jetty as its underlying connector.
\end_layout

\begin_layout Standard
And why stop there? Prudence (the 
\begin_inset Quotes eld
\end_inset

prudence
\begin_inset Quotes erd
\end_inset

 skeleton) builds on Restlet, letting you do all of that with your choice
 of JavaScript, Python, Ruby, PHP, Groovy or Clojure.
\end_layout

\begin_layout Subsubsection
Fleshing Out
\end_layout

\begin_layout Standard
Jetty's official distribution (which doesn't rely on Sincerity\SpecialChar \ldots{}
 yet) is a
 perfect example of why Sincerity needs to exist.
 
\begin_inset Quotes eld
\end_inset

Official Jetty
\begin_inset Quotes erd
\end_inset

 is a morass of XML files that effectively duplicate what a lightweight
 scripting language, like JavaScript does far more comprehensibly and with
 far greater power.
 If you're switching from 
\begin_inset Quotes eld
\end_inset

Official Jetty,
\begin_inset Quotes erd
\end_inset

 then you're in for a treat, as well as a sigh of relief.
\end_layout

\begin_layout Subsubsection
Extras
\end_layout

\begin_layout Standard
A nice example of a Jetty server with multiple contexts is provided: a static
 web server, a servlet container, and a web application installed as a WAR
 file:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add jetty.servlet.example : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(You can install this on its own, and it will pull in the basic skeleton
 as a dependency.)
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

/server/contexts/servlet-example/
\begin_inset Quotes erd
\end_inset

 is most elaborate: it shows you how you can drop in Java source code for
 your servlets and have them compiled as the server starts.
\end_layout

\begin_layout Standard
Additionally, two plugins are strongly recommended: logging and service.
 To install them:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add logging : add service : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following command will install the servlet examples with the recommended
 plugins into a Sincerity container created in the current directory, and
 then start it a service:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity create mycontainer : add jetty.servlet.example : add logging : add
 service : install : service jetty start
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To stop it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity use mycontainer : service jetty stop
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Restlet Skeleton
\end_layout

\begin_layout Standard
Restlet lets you dynamically generate web content, but it goes beyond just
 responding to client requests: it lets you map RESTful resources to URIs,
 while abstracting away the tricky HTTP mechanics involved (content negotiation,
 conditional HTTP) and providing rich tools for routing, filtering and data.
\end_layout

\begin_layout Standard
Restlet, on its own, requires Java, but Prudence (the 
\begin_inset Quotes eld
\end_inset

prudence
\begin_inset Quotes erd
\end_inset

 skeleton) builds on Restlet, letting you do all of the above with your
 choice of JavaScript, Python, Ruby, PHP, Groovy or Clojure.
\end_layout

\begin_layout Standard
To install the minimal skeleton:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add restlet : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To start you server:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity start restlet
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default port is 8080, so point your browser to http://localhost:8080.
\end_layout

\begin_layout Subsubsection
Fleshing Out
\end_layout

\begin_layout Standard
While Restlet requires you to write your resources in Java (see Prudence
 for an alternative that supports other languages), there is no reason for
 your bootstrapping code---the code that assembles your component, servers,
 clients, hosts and routes---to be so rigid.
 Restlet ships as a library, not as a deployable.
 The API for boostrapping your component is simple and elegant, but normally
 you would have to access it in Java.
\end_layout

\begin_layout Standard
JavaScript, Sincerity's natural language, provides a much more lightweight
 solution, and one that does not require you to recompile anything when
 all you want to change is your configuration.
 Of course, once your component is up and running, JavaScript plays no more
 role.
 (We mention that in case you're worried about performance, though you shouldn't
 be: the language engine is likely not the source of any bottlenecks in
 your application's performance.
 If you're ready to leave Java behind, take a look at the Prudence skeleton.)
\end_layout

\begin_layout Subsubsection
Extras
\end_layout

\begin_layout Standard
A simple example Restlet application, with a custom resource as well as
 static content:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add restlet.example : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(You can install this on its own, and it will pull in the basic skeleton
 as a dependency.)
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

/component/applications/example/
\begin_inset Quotes erd
\end_inset

 shows you how you can drop in Java source code for your resources and have
 them compiled as the component starts.
\end_layout

\begin_layout Standard
Additionally, two plugins are strongly recommended: logging and service.
 To install them:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add logging : add service : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following command will install the Restlet example with the recommended
 plugins into a Sincerity container created in the current directory, and
 then start it a service:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity create mycontainer : add restlet.example : add logging : add service
 : install : service restlet start
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To stop it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity use mycontainer : service restlet stop
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Prudence Skeleton
\end_layout

\begin_layout Standard
Since version 2.0, Prudence is designed from the ground-up around Sincerity.
 It's distributed exclusively as a Sincerity skeleton with a large collection
 of tightly integrated add-ons.
\end_layout

\begin_layout Standard
(Actually, it's the other way around! Sincerity was designed by Three Crickets
 precisely in order to make Prudence 2.0 sanely modular, building on many
 lessons learned while deploying Prudence 1.0 and 1.1.
 It was clear during development that there was nothing in the proposed
 solution that was specific to Prudence.
 And so Sincerity was born as a generic tool useful for many JVM projects.)
\end_layout

\begin_layout Subsection
Savory Framework Skeleton
\end_layout

\begin_layout Standard
The Savory Framework lets you develop scalable data-driven web applications
 in server-side JavaScript, centering on MongoDB as its data provider and
 Prudence as its RESTful base.
 It features strong integration with client-side 
\begin_inset Quotes eld
\end_inset

AJAX,
\begin_inset Quotes erd
\end_inset

 notably Ext JS and Sencha Touch, and clean-room integration with Facebook,
 Twitter, Google, etc..
 Services include a scalable email notification system, robust sitemap generatio
n (with special support for 
\emph on
very 
\emph default
large sites), authentication and authorization, and support for several
 markup languages.
\end_layout

\begin_layout Standard
(Like Sincerity and Prudence, the Savory Framework is developed by Three
 Crickets.
 The three products form a powerful stack!)
\end_layout

\begin_layout Subsection
Rails Skeleton
\end_layout

\begin_layout Standard
Rails, better known as 
\begin_inset Quotes eld
\end_inset

Ruby on Rails,
\begin_inset Quotes erd
\end_inset

 is a popular web development framework for Ruby.
 It combines a traditional MVC approach with a RESTful orientation and relies
 on relational database stores (MySQL, Postgres).
 Rails enjoys the elegant, often-imitated, ActiveRecord ORM, and a powerful
 
\begin_inset Quotes eld
\end_inset

scaffolding
\begin_inset Quotes erd
\end_inset

 feature that automatically generates models, views and controllers to which
 you can add your code.
 
\end_layout

\begin_layout Standard
If you're looking for a more strictly RESTful, minimalist alternative to
 Rails, while sticking to Ruby, take a look at Prudence (the 
\begin_inset Quotes eld
\end_inset

prudence
\begin_inset Quotes erd
\end_inset

 skeleton).
\end_layout

\begin_layout Standard
Rails is known to work very well on the JVM, but it can sometimes be painful
 to install everything and get it running.
 The Sincerity skeleton can do it all for you with one command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add rails : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This may take a minute or two: Rails is massive.
\end_layout

\begin_layout Standard
To start you server:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity start rails
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default port is 3000, so point your browser to http://localhost:3000.
\end_layout

\begin_layout Subsubsection
Fleshing Out
\end_layout

\begin_layout Standard
The skeleton will create an application for you under 
\begin_inset Quotes eld
\end_inset

/app/
\begin_inset Quotes erd
\end_inset

, so you don't have to run 
\begin_inset Quotes eld
\end_inset

rails new
\begin_inset Quotes erd
\end_inset

 to create one.
 Indeed, the correct way to start a new Rails project in Sincerity is simply
 to create a new container for it.
 That's the whole point of Sincerity!
\end_layout

\begin_layout Standard
The skeleton comes with a plugin to handle the 
\begin_inset Quotes eld
\end_inset

rails
\begin_inset Quotes erd
\end_inset

 tool for you, similarly to how Sincerity's Ruby plugin adds commands for
 common Ruby tools, such as 
\begin_inset Quotes eld
\end_inset

gem
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

rake
\begin_inset Quotes erd
\end_inset

.
 The benefit of this approach is that you do not have to explicitly change
 to the 
\begin_inset Quotes eld
\end_inset

/app/
\begin_inset Quotes erd
\end_inset

 directory to run the tool, and indeed you can chain it as is usual with
 Sincerity commands.
 It should work identically to the usual 
\begin_inset Quotes eld
\end_inset

rails
\begin_inset Quotes erd
\end_inset

 command: simple prefix 
\begin_inset Quotes eld
\end_inset

sincerity
\begin_inset Quotes erd
\end_inset

 to it.
 Examples:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity rails generate controller home index
\end_layout

\begin_layout Plain Layout

sincerity rails generate scaffold Post name:string title:string content:text
\end_layout

\begin_layout Plain Layout

sincerity rake db:migrate
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or as one Sincerity command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity use mycontainer : rails generate controller home index : rails
 generate scaffold Post name:string title:string content:text : rake db:migrate
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A quick note: Ruby is a bit sluggish to start up on the JVM, which you will
 notice when running 
\begin_inset Quotes eld
\end_inset

rails
\begin_inset Quotes erd
\end_inset

.
 However, don't let this worry you: once it's up and running, your Rails
 application will perform marvelously.
\end_layout

\begin_layout Standard
And that's it: from here on, it's all standard Rails goodness.
 You can go ahead with the tutorial at http://guides.rubyonrails.org/getting_start
ed.html, skipping step 3.2 (
\begin_inset Quotes eld
\end_inset

Creating the Blog Application
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
MySQL, PostgreSQL and SQLite are all supported out of the box, identically
 to how Rails works on other platforms.
\end_layout

\begin_layout Standard
If you need to access the Rails source code, you'll find it under 
\begin_inset Quotes eld
\end_inset

/libraries/ruby/lib/ruby/gems/1.8/gems/
\begin_inset Quotes erd
\end_inset

, which is where all Ruby gems will be installed in your container.
\end_layout

\begin_layout Subsubsection
Extras
\end_layout

\begin_layout Standard
Though the 
\begin_inset Quotes eld
\end_inset

rails
\begin_inset Quotes erd
\end_inset

 tool does support a daemon mode, Sincerity's service plugin is far more
 powerful and is strongly recommended.
 To install:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add service : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following command will install the Rails skeleton with the recommended
 plugins into a Sincerity container created in the current directory, and
 then start it a service:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity create mycontainer : add rails : add service : install : service
 rails start
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To stop it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity use mycontainer : service rails stop
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that Sincerity's logging plugin won't do you much good out of the box,
 because Rails uses Ruby's logging system, not the JVM's.
 However, it should be easy implement your own Ruby logger that delegates
 to standard JVM logging if that seems exciting to you.
\end_layout

\begin_layout Subsection
Django Skeleton
\end_layout

\begin_layout Standard
Django is a popular web development framework for Python.
 It relies on a traditional MVC approach and relational database stores
 (MySQL, Postgres).
 Django enjoys a strong ecosystem of drop-in features and snippets, but
 also provides a lot of features right in the box.
 Much the appeal of Django is the Python programming language: elegant,
 clean and supported by what must be the friendliest and most welcoming
 community of any programming language.
\end_layout

\begin_layout Standard
There are many advantages in running Django on the JVM instead of on the
 CPython reference platform: great performance, much improved scalability
 (there is no GIL in Jython), as well as access to any JVM library 
\emph on
in addition 
\emph default
to Python libraries.
 Of course, Sincerity makes it extremely easy and transparent to add both
 kinds of libraries as dependencies.
\end_layout

\begin_layout Standard
If you're looking for RESTful, minimalist alternative to Django, while sticking
 to Python, take a look at Prudence (the 
\begin_inset Quotes eld
\end_inset

prudence
\begin_inset Quotes erd
\end_inset

 skeleton).
\end_layout

\begin_layout Standard
Django can be difficult to install and get running on Jython, but of course
 it's trivial with Sincerity.
 In fact, you might find it easier than working with 
\begin_inset Quotes eld
\end_inset

official Django.
\begin_inset Quotes erd
\end_inset

 To install it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add django : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This may take a minute or two: Django is massive.
\end_layout

\begin_layout Standard
To start you server:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity start django
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default port is 8000, so point your browser to http://localhost:8000.
\end_layout

\begin_layout Subsubsection
Fleshing Out
\end_layout

\begin_layout Standard
The skeleton already has a minimal project ready for you under 
\begin_inset Quotes eld
\end_inset

/project/
\begin_inset Quotes erd
\end_inset

, so you don't have to run 
\begin_inset Quotes eld
\end_inset

django-admin.py startproject
\begin_inset Quotes erd
\end_inset

 to create one.
 Indeed, the correct way to start a new Django project in Sincerity is simply
 to create a new container for it.
 That's the whole point of Sincerity!
\end_layout

\begin_layout Standard
However, if you need to access 
\begin_inset Quotes eld
\end_inset

django-admin.py
\begin_inset Quotes erd
\end_inset

, it is located under your 
\begin_inset Quotes eld
\end_inset

/executables/
\begin_inset Quotes erd
\end_inset

 directory, so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity execute django-admin.py
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Much of the work with Django involves running 
\begin_inset Quotes eld
\end_inset

manage.py
\begin_inset Quotes erd
\end_inset

, which in this skeleton is located under 
\begin_inset Quotes eld
\end_inset

/project/manage.py
\begin_inset Quotes erd
\end_inset

.
 You can run it easily, from anywhere in the container, with a handy plugin:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity manage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A quick note: Python is a bit sluggish to start up on the JVM, which you
 will notice when running 
\begin_inset Quotes eld
\end_inset

manage
\begin_inset Quotes erd
\end_inset

.
 However, don't let this worry you: once it's up and running, your Django
 application will perform marvelously.
\end_layout

\begin_layout Standard
And that's it: from here on, it's all standard Django goodness.
 You can go ahead with the tutorial at https://docs.djangoproject.com/en/dev/intro
/tutorial01/, skipping the short 
\begin_inset Quotes eld
\end_inset

Creating a project
\begin_inset Quotes erd
\end_inset

 step.
\end_layout

\begin_layout Standard
Well, just one quick note: the database backend uses JDBC drivers (the JVM's
 relational database interface) instead of Python drivers, so the database
 engine names in your 
\begin_inset Quotes eld
\end_inset

settings.py
\begin_inset Quotes erd
\end_inset

 are a little bit different than in the official tutorial.
 You'll see the supported options commented in 
\begin_inset Quotes eld
\end_inset

settings.py
\begin_inset Quotes erd
\end_inset

.
 JDBC drivers for MySQL and PostgreSQL are included in the skeleton, but
 you must install the Oracle JDBC driver on your own.
 Also note that SQLite is not supported at this time.
\end_layout

\begin_layout Standard
If you need to access the Django source code, you'll find it under 
\begin_inset Quotes eld
\end_inset

/libraries/python/Lib/site-packages/
\begin_inset Quotes erd
\end_inset

, which is where all Python libraries will be installed in your container.
\end_layout

\begin_layout Subsubsection
Extras
\end_layout

\begin_layout Standard
Adding the service plugin is strongly recommended.
 To install:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add service : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following command will install the Django skeleton with the recommended
 plugins into a Sincerity container created in the current directory, and
 then start it a service:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity create mycontainer : add django : add service : install : service
 django start
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To stop it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity use mycontainer : service django stop
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that Sincerity's logging plugin won't do you much good out of the box,
 because Django uses Python's logging system, not the JVM's.
 However, it should be easy implement your own Python logger that delegates
 to standard JVM logging if that seems exciting to you.
\end_layout

\begin_layout Subsection
LWJGL Skeleton
\end_layout

\begin_layout Standard
The JVM is growing in popularity as a platform for game designers, due to
 its ability to easily have the game run on many operating systems, as well
 as in browsers.
 Much of this growth is due to the excellent LWJGL library, which makes
 easy to use hardware-accelerated features, such as 3D graphics and 3D sound,
 and to accept input from gaming controllers.
 While it does rely on native extensions to the JVM, they are supported
 on Linux, Windows, Mac OS X and Solaris.
 The author's favorite game, Minecraft, is based on it.
\end_layout

\begin_layout Standard
To install the barebones skeleton:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity add lwjgl : install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To start your game:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity start lwjgl
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This 
\begin_inset Quotes eld
\end_inset

lwjgl
\begin_inset Quotes erd
\end_inset

 program will detect your operating system, install the relevant native
 binaries into the container (if they aren't already installed), and then
 start the 
\begin_inset Quotes eld
\end_inset

game
\begin_inset Quotes erd
\end_inset

 program\SpecialChar \ldots{}
 except that with this barebones skeleton, there is no game to start.
 For something to play with, see the 
\begin_inset Quotes eld
\end_inset

lwjgl.example
\begin_inset Quotes erd
\end_inset

 skeleton.
 It includes a simple Space Invaders clone.
\end_layout

\begin_layout Subsubsection
Fleshing Out
\end_layout

\begin_layout Standard
Create a 
\begin_inset Quotes eld
\end_inset

/programs/game.js
\begin_inset Quotes erd
\end_inset

 that starts up your game.
 If you want your game to be written only in Java, this likely means entering
 your main class, like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sincerity.run('delegate:main', ['org.mycoolgame.Main'])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, don't rule out writing your game in JavaScript, or the host of
 other languages easily installable in Sincerity! You can even 
\begin_inset Quotes eld
\end_inset

drop down
\begin_inset Quotes erd
\end_inset

 to Java when you some low-level work, and keep the main game logic in a
 higher-level language.
\end_layout

\begin_layout Standard
This is especially useful if you want to provide a way for the community
 to provide plugins for your game: it would make it easier for novice programmer
s to contribute, and also allow such plugins to be distributed as simple
 text files.
 If you go this route, consider using Scripturian to allow high-performance,
 muli-threaded integration of the language engines.
 (Scripturian is the same library Sincerity uses for its plugins.)
\end_layout

\begin_layout Section
The Sincerity Framework
\end_layout

\begin_layout Section
The Sincerity JsDoc Template
\end_layout

\begin_layout Section
Extending Sincerity
\end_layout

\begin_layout Standard
Creating your own
\end_layout

\begin_layout Section
Repositories
\end_layout

\begin_layout Subsubsection
The Three Crickets Repository
\end_layout

\begin_layout Subsubsection
Maven Repositories
\end_layout

\begin_layout Subsubsection
Python and PyPI (a.k.a.
 
\begin_inset Quotes eld
\end_inset

The Cheese Factory
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Subsubsection
Ruby and Gems
\end_layout

\begin_layout Subsubsection
PHP and PEAR
\end_layout

\begin_layout Subsubsection
Community Repositories
\end_layout

\begin_layout Section
Appendix: Specifications
\end_layout

\begin_layout Subsection
Repositories
\end_layout

\begin_layout Subsection
Packages
\end_layout

\end_body
\end_document
